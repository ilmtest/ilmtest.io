Reviewed: December 1, 2025, 4:30 PM

### Architecture Review
The overall architecture is well-conceived for a static, JSON-driven Islamic text library on Cloudflare Pages, emphasizing O(1) lookups via indexes, lazy chunking, and extensible types. It strikes a strong balance between v1 minimalism (core browsing for Qur'an and Sahih al-Bukhari) and future-proofing (e.g., optional fields for tags, refs, and multi-translation). The shift to chunked content (500 items/file) and consolidated GlobalIndex resolves earlier monolithic file issues, enabling efficient client-side hydration without server runtime. Project organization in AGENTS.md is clear and iterative, with solid TDD foundations in tests/. The implementation_plan.md provides a robust blueprint, aligning data shapes with URL routability and caching strategies. Minor gaps exist in explicit caching directives for chunks and index splitting, but this is production-ready for Phase 2 with tweaks.

### Critique & Suggestions
- **1. Data Structure Efficiency**: The GlobalIndex (with `hadiths`, `surahs`, `ids`, `pages`) is efficient for client-side loading at ~1MB for Bukhari, as it enables single-fetch O(1) lookups across all patterns (e.g., hadith num → chunk ID + offset) without multiple HTTP requests. This outperforms separate indexes (~5-10 smaller files) by reducing network roundtrips, and 1MB is cacheable in modern browsers (e.g., <5% of typical session memory). However, for ultra-low-bandwidth users (e.g., mobile in developing regions), split it into two: a "core" index (~200KB: `hadiths` + `surahs` for primary lookups) and a "pages" supplement (~800KB, lazy-loaded only for pagination views). Update headings.json to reference the core index exclusively, and add a `requiresPagesIndex: boolean` flag in book metadata for conditional loading.
  
- **2. Chunking Strategy**: Deterministic chunking via `floor(globalIndex / 500)` is robust for deep linking, as it decouples stable excerpt IDs from physical file structure—e.g., linking to "2576:1" resolves via index to chunk 0, offset 0, without recalculating on inserts. For static texts like Qur'an/Hadith (immutable post-migration), insertion risks are negligible; corrections can trigger full re-migration (Bun scripts are fast, <10s). To enhance resilience, add a `chunkManifest.json` per book with `{ chunkId: { startGlobalIndex: number, endGlobalIndex: number, file: string } }`—this allows future variable chunk sizes (e.g., by volume for uneven Hadith distribution) without breaking links. Validate in tests by simulating offsets post-"insert."

- **3. Type Safety**: The types in data-types-v1.ts (inferred from AGENTS.md: optional `type`, domain-specific `meta` like `VerseMetadata`/`HadithMetadata`, extensible `refs?`) are appropriately strict for v1 (e.g., union discriminants enforce `surah/verse` for Quran, `volume/pp/hadithNum?` for Hadith, no `any`) while flexible for future content—Fiqh/Tafsir can slot into `meta` as `FatawaMetadata { volume, pp }` without schema breaks, and optional fields (e.g., `tags?: string[]`, `roman?: string`) align with future-roadmap.md's non-breaking extensions. Suggestion: Add a discriminated union for `meta` via `type` (e.g., `if type === 'verse' then meta: VerseMetadata`), using TypeScript's `satisfies` for runtime checks. This prevents v2 bloat while allowing `Omit<ExcerptV1, 'meta'> & { meta: unknown }` as a migration shim.

- **4. Client-Side Logic**: No major bottlenecks foreseen in proposed functions (from AGENTS.md Next Steps), as they leverage GlobalIndex for O(1) resolution → single chunk fetch (<200KB) + in-memory slice. `getHadithByNumber(bookId, num)`: Index lookup → chunk load → return; <50ms even on 3G. `getVersesBySurah(bookId, surah)`: Use headings.json `indexRange` for start/end → fetch 1-2 chunks (e.g., Surah 2 spans ~2 chunks) → slice; handles 286 verses efficiently. For listing functions: `listExcerptsInBook()` risks loading all chunks (23 for Bukhari, ~10MB)—mitigate with virtualized lists (e.g., React Window) and prefetch only visible ranges via `pages` index. `listChapters`/`listSurahs`/`listBooks`: Purely index-driven (<10KB), instant. Add a shared `fetchChunk(bookId, chunkId)` with LRU cache (e.g., `lru-cache` npm, 10 chunks max) to avoid re-fetches on navigation; benchmark in tests for <100ms end-to-end.

- **5. Testing**: The TDD strategy (from AGENTS.md/tests/) covers migration/integration/validation well (76 passing tests), but gaps for Data Access Layer include: no e2e mocks for fetch (use MSW for HTTP simulation of chunks/indexes); missing edge-case params (e.g., invalid num → graceful error, cross-chunk surah spans); no perf assertions (e.g., `expect(loadTime).toBeLessThan(50)` via `performance.now()`); and incomplete coverage for listings (e.g., `listExcerptsInBook` with virtualization stubs). Suggestion: Add `tests/data-access.test.ts` with `it.each` for lookups (parametrize bookId/num/verse), mock `fetch` globally, and integrate Playwright for UI-e2e (e.g., navigate /quran/2/255 → verify excerpt). Aim for 90% coverage on access layer before UI.

### Risk Assessment
- **Index Size/Caching**: 1MB GlobalIndex could bloat initial payload on repeat visits if not ETag'd properly—Cloudflare may cache indefinitely, but add `Cache-Control: max-age=86400, immutable` headers via next.config.js to force revalidation on data updates (rare). Mobile Safari may evict mid-session; fallback to progressive enhancement (load core index first).
- **Chunk Resolution Failures**: If migration drifts (e.g., reordering excerpts), deep links break silently—risk low but mitigate with `data-validation.test.ts` asserting index offsets match content lengths post-chunking.
- **Extensibility Overreach**: Optional fields tempt v1 creep (e.g., premature `tags`); enforce via Biome linter rule ignoring unused v2+ props.
- **Client Memory**: Full Bukhari load (23 chunks) hits ~10MB RAM—fine for desktops, but cap via cache eviction; test on low-end devices (e.g., Chrome DevTools throttled CPU).
- **Build Time**: Re-migration on content fixes could spike (e.g., 5min for Bukhari)—parallelize chunks in Bun scripts.

### Approval/Changes Required
Proceed with TDD implementation for Phase 2 (Core API/Data Access), as the foundation is solid—start with `tests/data-access.test.ts` to drive `get*` functions. Minor refactors first: (1) Add `chunkManifest.json` and core/supplemental index split (1-2 hours); (2) Discriminated `meta` union in data-types-v1.ts (30min). No full refactor needed; these tweaks enhance robustness without delaying momentum. Post-Phase 2, benchmark full navigation flows before Phase 3 UI.